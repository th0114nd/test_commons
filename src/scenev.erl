%% @doc
%%   A scenev_model is a behaviour which describes a scenario and a set of events,
%%   deduces the expected results and then observes and compares the actual results when
%%   the events are fed to the scenario. The scenario is expected to be a description
%%   of a running erlang configuration (e.g., a supervisor hierarchy with children),
%%   while the events are a series of exported function calls or actions that impact
%%   the corresponding running erlang scenario.
%%
%%   A collection of scenarios can be generated either by using file:consult/1 on a
%%   static set of scenario descriptions, or by using proper to generate random
%%   scenario descriptions. A static set could be generated by saving randomly
%%   generated scenarios or by hand-editing specific scenarios that reproduce an
%%   actual bug observed in production afflicting the software being tested.
%% @end
-module(scenev).

%% External API: Certifying code against a set of proper model instances.
-export([
         test_all_models/1,
         verify_all_scenarios/1
        ]).

%% Steps used to validate a single scenario.
-export([
         passed_test_case/2
        ]).

-include("scenev.hrl").

%% Behaviour callbacks for generating a scenev_model and expected outcomes
-callback get_all_test_model_ids() -> [{Model_Id :: scenev_model_id(), Source :: scenev_model_source()}].
-callback transform_raw_scenario(Scenario_Num :: pos_integer(), Raw_Scenario :: term()) -> {single, scenev_scenario()} |
                                                                                           {many,  [scenev_scenario()]}.
-callback deduce_expected(Scenario_Instance :: scenev_scenario()) -> Expected_Status :: term().

%% Behaviour callbacks used per scenario when validating against the model
-callback vivify_scenario  (scenev_scenario())    -> scenev_live_ref().
-callback translate_dsl    (scenev_dsl_desc())    -> scenev_live_desc().
-callback translate_events (scenev_dsl_events())  -> scenev_live_events().

-callback generate_observation(scenev_scenario(), scenev_live_ref()) -> Observed_Status :: term().

-callback passed_test_case(Case_Number     :: pos_integer(),
                           Expected_Status :: scenev_dsl_status(),
                           Observed_Status :: scenev_live_status())
              -> boolean().


%%-------------------------------------------------------------------
%% External API for testing all models implemented by a module.
%%-------------------------------------------------------------------

%% Cb_Module is the callback module provided by the model instance.
-spec test_all_models(module()) -> [{scenev_model_id(), scenev_model_result()}].
test_all_models(Cb_Module) ->
    {ok, IDs} = exec_callback(Cb_Module, get_all_test_model_ids, []),
    [begin
         Test_Model = generate_model(Cb_Module, Model_Id, Source),
         {Model_Id, verify_all_scenarios(Test_Model)}
     end || {Model_Id, Source} <- IDs].

-spec generate_model(module(), scenev_model_id(), scenev_model_source()) -> scenev_model().
generate_model(Cb_Module, Model_Id, {file, Full_Name} = Source) ->
    {ok, Raw_Scenarios} = file:consult(Full_Name),
    transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios);
generate_model(Cb_Module, Model_Id, {mfa, {Mfa_Module, Function, Args}} = Source) ->
    {ok, Raw_Scenarios} = apply(Mfa_Module, Function, [Cb_Module, Model_Id | Args]),
    transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios).

transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios) ->
    {_, Scenarios} = lists:foldl(fun(Raw_Scenario, {Scenario_Num, Scenarios}) ->
                                     {Scenario_Num + 1,
                                      case exec_callback(Cb_Module, transform_raw_scenario, 
                                              [Scenario_Num, Raw_Scenario]) of
                                          {ok, {single, OneScen}} -> [[OneScen] | Scenarios];
                                          {ok, {many, ManyScens}} -> [ManyScens | Scenarios];
                                          _Error -> Scenarios
                                      end} end, 
                                  {1, []}, 
                                  Raw_Scenarios),
    #scenev_model{id=Model_Id, source=Source, behaviour=Cb_Module, scenarios=lists:reverse(lists:append(Scenarios))}.

-spec verify_all_scenarios(Test_Model :: scenev_model()) -> scenev_model_result().
%% @doc
%%   Given a model and corresponding scenarios, generate observed test cases and
%%   validate that they all pass.
%% @end
verify_all_scenarios(#scenev_model{behaviour=Cb_Module, scenarios=Scenarios}) ->
    {Success, Success_Case_Count, Failed_Cases}
        = lists:foldl(fun(#scenev_scenario{instance=Case_Number} = Scenario,
                          {Result, Success_Count, Failures}) when is_integer(Case_Number), 
                                                                   Case_Number > 0, 
                                                                   is_boolean(Result),
                                                                   is_integer(Success_Count),
                                                                   Success_Count >= 0,
                                                                   is_list(Failures) ->
                        try
                            {ok, Expected} = exec_callback(Cb_Module, deduce_expected,      [Scenario]),
                            {ok, Live_Ref} = exec_callback(Cb_Module, vivify_scenario,      [Scenario]),
                            {ok, Observed} = exec_callback(Cb_Module, generate_observation, [Scenario, Live_Ref]),
                            Test_Case = #scenev_test_case{scenario = Scenario,
                                                          expected_status = Expected,
                                                          observed_status = Observed},
                            case passed_test_case(Cb_Module, Test_Case) of
                                %% Errors should not be possible as we have filled in Observed_Case properly.
                                {ok, true}  -> {Result, Success_Count+1, Failures};
                                {ok, false} -> {false,  Success_Count,   [Test_Case | Failures]}
                            end
                        catch Error:Type ->
                                error_logger:error_msg("Scenario instance ~p crashed with ~p~n  Stacktrace: ~p~n",
                                                       [Scenario, {Error, Type}, erlang:get_stacktrace()]),
                                {false, Success_Count, [Scenario | Failures]}
                        end
                end,
                {true, 0, []},
                Scenarios),
    {Success, Success_Case_Count, lists:reverse(Failed_Cases)}.


%%-------------------------------------------------------------------
%% Internal API steps used to validate a single scenario.
%%-------------------------------------------------------------------

-spec passed_test_case(module(), Observed_Test_Case :: scenev_test_case())
      -> {ok, boolean()}
             | {error, {expected_status_not_generated, scenev_test_case()}}
             | {error, {observed_status_not_generated, scenev_test_case()}}.
%% @doc
%%   Given a test case that has already been executed and contains an observed
%%   result status, use the behaviour module to verify if the expected status
%%   matches the observed status.
%% @end
passed_test_case(_Cb_Module, #scenev_test_case{expected_status=?SCENEV_MISSING_TEST_CASE_ELEMENT} = Observed_Test_Case) ->
    {error, {expected_status_not_generated, Observed_Test_Case}};
passed_test_case(_Cb_Module, #scenev_test_case{observed_status=?SCENEV_MISSING_TEST_CASE_ELEMENT} = Observed_Test_Case) ->
    {error, {observed_status_not_generated, Observed_Test_Case}};
passed_test_case( Cb_Module, #scenev_test_case{scenario=#scenev_scenario{instance=Case_Number}} = Observed_Test_Case)
  when is_integer(Case_Number), Case_Number > 0 ->
    #scenev_test_case{expected_status=Expected, observed_status=Observed} = Observed_Test_Case,
    exec_callback(Cb_Module, passed_test_case, [Case_Number, Expected, Observed]).

%% @private
%% @doc
%%   Executes the modules callback, and logs an error if one is found.
%% @end
-spec exec_callback(module(), atom(), [any()]) -> any().
exec_callback(Mod, Fun, Args)
  when is_atom(Mod), is_atom(Fun), is_list(Args)->
    try {ok, apply(Mod, Fun, Args)}
    catch Error:Type -> 
        error_logger:error_msg("Caught ~p error in ~p:~p/~p~n~p",
                [{Error, Type}, Mod, Fun, length(Args), erlang:get_stacktrace()]),
        {Error, Type}
    end.
