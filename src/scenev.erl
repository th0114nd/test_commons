%% @doc
%%   A scenev_model is a behaviour which describes a scenario and a set of events,
%%   deduces the expected results and then observes and compares the actual results when
%%   the events are fed to the scenario. The scenario is expected to be a description
%%   of a running erlang configuration (e.g., a supervisor hierarchy with children),
%%   while the events are a series of exported function calls or actions that impact
%%   the corresponding running erlang scenario.
%%
%%   A collection of scenarios can be generated either by using file:consult/1 on a
%%   static set of scenario descriptions, or by using proper to generate random
%%   scenario descriptions. A static set could be generated by saving randomly
%%   generated scenarios or by hand-editing specific scenarios that reproduce an
%%   actual bug observed in production afflicting the software being tested.
%% @end
-module(scenev).

%% External API: Certifying code against a set of proper model instances.
-export([
         test_all_models/1,
         verify_all_scenarios/1
        ]).

%% Steps used to validate a single scenario.
-export([
         generate_test_case/2,
         generate_observed_case/2,
         passed_test_case/2
        ]).

-include("scenev.hrl").

%% Behaviour callbacks for generating a scenev_model and expected outcomes
-callback get_all_test_model_ids() -> [{Model_Id :: scenev_model_id(), Source :: scenev_model_source()}].
-callback transform_raw_scenario(Scenario_Num :: pos_integer(), Raw_Scenario :: term()) -> {single, scenev_scenario()} |
                                                                                           {many,  [scenev_scenario()]}.
                                                                                                    
-callback deduce_expected(Scenario_Instance :: scenev_scenario()) -> Expected_Status :: term().

%% Behaviour callbacks used per scenario when validating against the model
-callback vivify_scenario  (scenev_scenario())    -> scenev_live_ref().
-callback translate_dsl    (scenev_dsl_desc())    -> scenev_live_desc().
-callback translate_events (scenev_dsl_events())  -> scenev_live_events().

-callback generate_observation(Live_Model_Ref     :: scenev_live_ref(),
                               Test_Case_Instance :: scenev_test_case())
              -> Observed_Status :: term().

-callback passed_test_case(Case_Number     :: pos_integer(),
                           Expected_Status :: scenev_dsl_status(),
                           Observed_Status :: scenev_live_status())
              -> boolean().


%%-------------------------------------------------------------------
%% External API for testing all models implemented by a module.
%%-------------------------------------------------------------------

%% Cb_Module is the callback module provided by the model instance.
-spec test_all_models(module()) -> [{scenev_model_id(), scenev_model_result()}].
test_all_models(Cb_Module) ->
    [begin
         Test_Model = generate_model(Cb_Module, Model_Id, Source),
         {Model_Id, verify_all_scenarios(Test_Model)}
     end || {Model_Id, Source} <- Cb_Module:get_all_test_model_ids()].

-spec generate_model(module(), scenev_model_id(), scenev_model_source()) -> scenev_model().
generate_model(Cb_Module, Model_Id, {file, Full_Name} = Source) ->
    {ok, Raw_Scenarios} = file:consult(Full_Name),
    transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios);
generate_model(Cb_Module, Model_Id, {mfa, {Mfa_Module, Function, Args}} = Source) ->
    {ok, Raw_Scenarios} = apply(Mfa_Module, Function, [Cb_Module, Model_Id | Args]),
    transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios).

transform_raw_scenarios(Cb_Module, Model_Id, Source, Raw_Scenarios) ->
    {_, Scenarios} = lists:foldl(fun(Raw_Scenario, {Scenario_Num, Scenarios}) ->
                                     {Scenario_Num + 1,
                                      case exec_callback(Cb_Module, transform_raw_scenario, 
                                              [Scenario_Num, Raw_Scenario]) of
                                          {single, OneScen} -> [[OneScen] | Scenarios];
                                          {many, ManyScens} -> [ManyScens | Scenarios];
                                          _Error -> Scenarios
                                      end} end, 
                                  {1, []}, 
                                  Raw_Scenarios),
    #scenev_model{id=Model_Id, source=Source, behaviour=Cb_Module, scenarios=lists:reverse(lists:append(Scenarios))}.

-spec verify_all_scenarios(Test_Model :: scenev_model()) -> scenev_model_result().
%% @doc
%%   Given a model and corresponding scenarios, generate observed test cases and
%%   validate that they all pass.
%% @end
verify_all_scenarios(#scenev_model{scenarios=[]}) -> {true, []};
verify_all_scenarios(#scenev_model{behaviour=Cb_Module, scenarios=Scenarios}) ->
    {Success, Success_Case_Count, Failed_Cases}
        = lists:foldl(fun(#scenev_scenario{instance=Case_Number} = Scenario_Instance,
                          {Boolean_Result, Success_Case_Count, Failures}) when Case_Number > 0 ->
                        try
                            Test_Case     = generate_test_case     (Cb_Module, Scenario_Instance),
                            Observed_Case = generate_observed_case (Cb_Module, Test_Case),
                            case passed_test_case(Cb_Module, Observed_Case) of
                                %% Errors should not be possible as we have filled in Observed_Case properly.
                                {ok, true}  -> {Boolean_Result, Success_Case_Count+1, Failures};
                                {ok, false} -> {false,          Success_Case_Count,   [Observed_Case | Failures]}
                            end
                        catch Error:Type ->
                                error_logger:error_msg("Scenario instance ~p crashed with ~p~n  Stacktrace: ~p~n",
                                                       [Scenario_Instance, {Error, Type}, erlang:get_stacktrace()]),
                                {false, Success_Case_Count, [Scenario_Instance | Failures]}
                        end
                end, {true, 0, []}, Scenarios),
    {Success, Success_Case_Count, lists:reverse(Failed_Cases)}.


%%-------------------------------------------------------------------
%% Internal API steps used to validate a single scenario.
%%-------------------------------------------------------------------

-spec generate_test_case(module(), scenev_scenario()) -> scenev_test_case().
%% @doc
%%   Given a test case scenario to be set up, and a series of events, create a full
%%   test case by letting the behaviour module deduce the resulting status after
%%   executing the scenario. The passed in test_case should have all fields specified
%%   and not just a default initialization of the scenev_scenario() type.
%% @end
generate_test_case(Cb_Module, #scenev_scenario{instance = Case_Number} = Scenario_Instance)
  when is_integer(Case_Number), Case_Number >= 0 ->
    Expected_Status = exec_callback(Cb_Module, deduce_expected, [Scenario_Instance]),
    #scenev_test_case{scenario=Scenario_Instance, expected_status=Expected_Status}.

-spec generate_observed_case(module(), Unexecuted_Test_Case :: scenev_test_case()) -> Result :: scenev_test_case().
%% @doc
%%   Given a test case that has not been executed yet, set up the scenario, stream
%%   the events to the scenario and then retrieve the observed status. This function
%%   returns an instance of an observed test case that can be validated later.
%% @end
generate_observed_case(Cb_Module,
                       #scenev_test_case{scenario=#scenev_scenario{instance=Case_Number} = Scenario_Dsl,
                                            observed_status=?SCENEV_MISSING_TEST_CASE_ELEMENT} = Unexecuted_Test_Case)
  when is_integer(Case_Number), Case_Number > 0 ->
    Live_Model_Ref = exec_callback(Cb_Module, vivify_scenario, [Scenario_Dsl]),
    Observation    = exec_callback(Cb_Module, generate_observation, [Live_Model_Ref, Unexecuted_Test_Case]),
    Unexecuted_Test_Case#scenev_test_case{observed_status=Observation}.

-spec passed_test_case(module(), Observed_Test_Case :: scenev_test_case())
      -> {ok, boolean()}
             | {error, {expected_status_not_generated, scenev_test_case()}}
             | {error, {observed_status_not_generated, scenev_test_case()}}.
            
%% @doc
%%   Given a test case that has already been executed and contains an observed
%%   result status, use the behaviour module to verify if the expected status
%%   matches the observed status.
%% @end
passed_test_case(_Cb_Module, #scenev_test_case{expected_status=?SCENEV_MISSING_TEST_CASE_ELEMENT} = Observed_Test_Case) ->
    {error, {expected_status_not_generated, Observed_Test_Case}};
passed_test_case(_Cb_Module, #scenev_test_case{observed_status=?SCENEV_MISSING_TEST_CASE_ELEMENT} = Observed_Test_Case) ->
    {error, {observed_status_not_generated, Observed_Test_Case}};
passed_test_case( Cb_Module, #scenev_test_case{scenario=#scenev_scenario{instance=Case_Number}} = Observed_Test_Case)
  when is_integer(Case_Number), Case_Number > 0 ->
    #scenev_test_case{expected_status=Expected, observed_status=Observed} = Observed_Test_Case,
    {ok, exec_callback(Cb_Module, passed_test_case, [Case_Number, Expected, Observed])}.

%% @private
%% @doc
%%   Executes the modules callback, and logs an error if one is found.
%% @end
-spec exec_callback(module(), atom(), [any()]) -> any().
exec_callback(Mod, Fun, Args)
  when is_atom(Mod), is_atom(Fun), is_list(Args)->
    try apply(Mod, Fun, Args)
    catch Error:Type -> 
        error_logger:error_msg("Caught ~p error in ~p:~p/~p~n~p",
                [{Error, Type}, Mod, Fun, length(Args), erlang:get_stacktrace()]),
        {Error, Type}
    end.
